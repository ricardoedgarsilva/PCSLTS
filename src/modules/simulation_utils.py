from modules.dependencies import *

def run_ltspice(config: dict, mode="-b"):
    """
    Run an LTspice simulation using the specified circuit file.

    This function runs an LTspice simulation using the specified circuit file. 
    It opens an LTspice subprocess and runs the simulation with the given circuit file.

    Parameters:
    config (dict): A dictionary containing the configuration details for the simulation, including the path to the circuit file.

    Returns:
    None
    """

    print("\rRunning LTspice simulation...", end=' ' * 20)

    circuit_path = os.path.join(config["simulation"]["savedir"], "circuit.cir")

    
    try:
        if mode != "-b" and mode != "":
            raise ValueError("Invalid mode. Use '-b' for background or '' for foreground.")

        subprocess.run(["ltspice", mode, circuit_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        print("\rLTspice simulation completed.", end=' ' * 20)


    except Exception as e:
        print(f"An error occurred while running LTspice: {e}")

def import_results(config):
    """
    Import simulation results from an LTspice simulation.

    This function reads simulation data from a .raw file generated by LTspice, based on the 
    configuration specified in `config`. It extracts voltage data at specific intervals
    for different layers and columns in a simulation geometry.

    Parameters:
    config (dict): A dictionary containing configuration data with keys:
                   - 'simulation': a sub-dictionary containing:
                     - 'savedir': the directory where simulation results are saved.
                     - 'geometry': a list of tuples, where each tuple represents the
                       number of rows and columns for each layer in the simulation.
                     - 'freq': the frequency at which data points are sampled.

    Returns:
    list: A list of numpy arrays. Each array corresponds to a layer in the simulation
          geometry, containing voltage data for each column at specified intervals.
    """

    print("\rImporting LTspice simulation results...", end=' ' * 20)

    # Extract configuration details
    save_dir = config['simulation']['savedir']
    geometry = config['simulation']['geometry']
    precision = config['simulation']['precision']
    timesteps = config['data_shape']['x_train'][0] + config['data_shape']['x_test'][0]

    # Load and parse the LTspice data
    data_file_path = os.path.join(save_dir, "circuit.raw")
    data = ltspice.Ltspice(data_file_path)
    data.parse()

    # Process time data and find indices
    time_data = np.round(data.get_data("time"), precision)
    time_list = [config['simulation']['timestep'] * i for i in range(timesteps)]

    # Initialize results list and add the output layer
    results = [np.zeros((timesteps, rows)) for rows, _ in geometry]
    results.append(np.zeros((timesteps, geometry[-1][1])))

    # Extract voltage data for each layer row
    for layer in range(0, len(geometry)):
        for row in range(0, geometry[layer][0]):
            voltage_header = f"V(nin_{layer}_{row})"
            voltage_data = data.get_data(voltage_header)
            f = interp1d(time_data, voltage_data)
            results[layer][:,row] = f(time_list)
        
    # Extract voltage data of the system output
    layer = len(geometry)
    for col in range(geometry[-1][1]):
        voltage_header = f"V(nin_{layer}_{col})"
        voltage_data = data.get_data(voltage_header)
        f = interp1d(time_data, voltage_data)
        results[-1][:,col] = f(time_list)

    print("\rLTspice simulation results imported.", end=' ' * 20)

    return results

def initialize_weights(config: dict):
    """
    Initialize random weights for each node in a given geometry.

    This function creates a nested list of weights where each sublist corresponds to a layer in the geometry,
    and each sub-sublist corresponds to the nodes in that layer. The weights are initialized randomly.

    Parameters:
    config (dict): A dictionary containing the simulation configuration, specifically the geometry of the network.

    Returns:
    list: A nested list containing the weights for each node in each layer of the geometry.
    """
    geometry = config["simulation"]["geometry"]

    # np.random.rand() returns a random number between 0 and 1
    weights = [np.zeros((rows, cols)) for rows, cols in geometry]

    return weights
